function mla_surrogate_optimization_main_lightpath_find()
    % 微透镜阵列代理模型优化主程序 
    % 作者：yoka02035
    % 创建时间：2025-05-22 16:32:17
    
    % 设置随机数种子以确保可重复性
    rng('default');
    rng(20250522);  % 使用当前日期作为种子
    
    % 清理工作区并设置日志
    cleanup_and_setup();
    
    try
        % 初始化数据和参数
        [X, Y, dx, lambda] = prepare_static_data();
        [lb, ub, options] = setup_optimization_parameters();
    
        % 初始化最优解记录
        best_solution = struct('value', Inf, ...
                             'parameters', [], ...
                             'details', [], ...
                             'iteration', 0, ...
                             'timestamp', '');
    
        % 生成初始采样点
        initial_points = generate_initial_samples(lb, ub, 250);
        
        % 评估初始采样点
        initial_values = zeros(250, 1);
        initial_details = cell(250, 1);

        fprintf('开始评估初始采样点...\n');
        for i = 1:250
            [initial_values(i), initial_details{i}] = evaluate_mla_design_wrapper(...
                initial_points(i,:), X, Y, dx, lambda);
            fprintf('完成初始采样点评估 %d/250\n', i);
        end
        
        % 训练初始代理模型
        surrogate_model = train_surrogate_model(initial_points, initial_values);
        
        % 更新最优解
        [min_val, min_idx] = min(initial_values);
        if min_val < best_solution.value
            best_solution.value = min_val;
            best_solution.parameters = initial_points(min_idx,:);
            best_solution.details = initial_details{min_idx};
            best_solution.iteration = 0;
            best_solution.timestamp = datestr(now, 'yyyy-mm-dd_HH:MM:SS');
        end
        
        % 主优化循环
        max_iterations = 200;
        history = initialize_history(initial_points, initial_values);
        
        for iter = 1:max_iterations
            % 选择下一个评估点
            next_point = select_next_point(surrogate_model, lb, ub, best_solution.value);
            
            % 评估新点
            [next_value, next_details] = evaluate_mla_design_wrapper(next_point, X, Y, dx, lambda);
            
            % 更新最优解
            if next_value < best_solution.value
                best_solution.value = next_value;
                best_solution.parameters = next_point;
                best_solution.details = next_details;
                best_solution.iteration = iter;
                best_solution.timestamp = datestr(now, 'yyyy-mm-dd_HH:MM:SS');
                
                fprintf('第 %d 次迭代发现新的最优解:\n', iter);
                fprintf('  均匀度: %.4f%%\n', next_value * 100);
                fprintf('  微透镜尺寸: %.2f μm\n', next_point(4) * 1e6);
                fprintf('  矢高: %.2f μm\n', next_point(5) * 1e6);
            end
            
            % 更新历史记录和代理模型
            history = update_history(history, next_point, next_value);
            surrogate_model = update_surrogate_model(surrogate_model, next_point, next_value);
            
            % 保存检查点
            save_checkpoint(iter, surrogate_model, history, best_solution);
            
            % 显示进度
            display_progress(iter, max_iterations, best_solution);
            
            % 检查收敛性
            if check_convergence(history, iter)
                fprintf('优化已收敛,在迭代 %d 终止\n', iter);
                break;
            end
        end
        
        % 最终评估和结果保存 - 使用精确评估函数
        finalize_optimization_enhanced(best_solution, X, Y, dx, lambda, history);
        
    catch ME
        % 错误处理
        handle_error(ME);
        rethrow(ME);
    end
end

% ... existing code ...

function [lb, ub, options] = setup_optimization_parameters()
    % 设置光路参数优化范围
    % 只优化d1, d2, d3三个参数
    
    % 光路参数范围
    lb = [1e-3, 1e-3, 30e-3];     % 下界 [d1, d2, d3]
    ub = [20e-3, 30e-3, 85e-3];   % 上界 [d1, d2, d3]
    
    % 验证参数维度
    validateattributes(lb, {'numeric'}, {'vector', 'numel', 3}, 'setup_optical_path_parameters', 'lb');
    validateattributes(ub, {'numeric'}, {'vector', 'numel', 3}, 'setup_optical_path_parameters', 'ub');
    
    % 优化选项
    options = struct();
    options.MaxIterations = 100;
    options.TolFun = 1e-6;
    options.Display = 'iter';
end

function samples = generate_initial_samples(lb, ub, n)
    % 生成光路参数的初始采样点
    % 输入:
    %   lb - 参数下界 (1×3 向量)
    %   ub - 参数上界 (1×3 向量)
    %   n  - 样本数量
    % 输出:
    %   samples - n×3 矩阵，每行包含一组参数 [d1, d2, d3]
    
    % 输入验证
    validateattributes(lb, {'numeric'}, {'vector', 'numel', 3}, 'generate_initial_optical_samples', 'lb');
    validateattributes(ub, {'numeric'}, {'vector', 'numel', 3}, 'generate_initial_optical_samples', 'ub');
    validateattributes(n, {'numeric'}, {'scalar', 'positive', 'integer'}, 'generate_initial_optical_samples', 'n');
    
    % 确保lb和ub是行向量
    lb = lb(:)';
    ub = ub(:)';
    
    % 使用拉丁超立方采样
    samples = lhsdesign(n, length(lb));
    
    % 映射到实际参数范围
    samples = samples .* (ub - lb) + lb;
    
    % 验证生成的样本维度
    validateattributes(samples, {'numeric'}, {'size', [n, 3]}, 'generate_initial_optical_samples', 'samples');
end

function [uniformity, details_for_saving] = evaluate_optical_path_wrapper(x, T_mla, X, Y, dx, lambda)
    % 评估光路参数的包装函数
    % 输入:
    %   x - 光路参数 [d1, d2, d3]
    %   T_mla - 已优化的MLA复振幅透射率
    %   X, Y - 坐标网格
    %   dx - 采样间隔
    %   lambda - 波长
    % 输出:
    %   uniformity - 均匀度评估值
    %   details_for_saving - 详细信息结构体
    
    % 初始化返回值,确保在任何情况下都有值返回
    uniformity = inf;
    details_for_saving = struct();
    
    % 确保参数为行向量
    x = reshape(x, 1, []);
    
    try
        validateattributes(x, {'numeric'}, {'vector', 'numel', 3, 'finite'}, ...
            'evaluate_optical_path_wrapper', 'x');
        
        % 解析参数
        d1 = x(1);       % MLA间距离
        d2 = x(2);       % MLA到透镜距离
        d3 = x(3);       % 透镜到目标面距离
        
        % 光束传播模拟
        I_out = simulate_beam_propagation_fixed_mla(T_mla, X, Y, dx, lambda, d1, d2, d3);
        I_out_norm = I_out / max(I_out(:));
        
        target_energy_ratio = 0.9; % 目标能量占比（90%）
        [energy_square_mask, L_energy_square] = find_dynamic_energy_square(I_out, dx, target_energy_ratio, X, Y);

        ideal_length = 12e-3; % 理想边长12mm
        [area_penalty, area_stats] = calculate_area_constraint_penalty(L_energy_square, ideal_length);
        [rms_uniformity, uniformity_stats] = calculate_uniformity_in_region(I_out_norm, energy_square_mask);
        rms_uniformity = rms_uniformity * 5;
        [edge_penalty, edge_stats] = calculate_edge_steepness_penalty(I_out_norm, energy_square_mask);
        edge_penalty = edge_penalty / 5;  % 缩小5倍
        [energy_penalty, energy_stats] = calculate_fixed_region_energy_penalty(I_out_norm, X, Y);
        
        % 更新权重设置
        w_rms_raw = 4.0;       % 均匀度权重
        w_area_raw = 3.0;      % 面积约束权重
        w_edge_raw = 0.25;     % 边缘陡峭度惩罚权重
        w_energy_raw = 3.0;    % 固定区域能量惩罚权重
        
        % 计算总权重
        total_weight = w_rms_raw + w_area_raw + w_edge_raw + w_energy_raw;
        
        % 归一化权重
        w_rms = w_rms_raw / total_weight;
        w_area = w_area_raw / total_weight;
        w_edge = w_edge_raw / total_weight;
        w_energy = w_energy_raw / total_weight;
        
        % 计算目标值
        uniformity = w_rms * rms_uniformity/100 + ...
                    w_area * area_penalty + ...
                    w_edge * edge_penalty + ...
                    w_energy * energy_penalty;
        
        % 计算实际能量比例
        current_energy = sum(sum(I_out .* energy_square_mask)) * dx * dx;
        total_energy = sum(I_out(:)) * dx * dx;
        actual_energy_ratio = current_energy / total_energy;

        % 简化的详细信息结构
        details_for_saving = struct(...
            'timestamp', datestr(now, 'yyyy-mm-dd HH:MM:SS'), ...
            'parameters', x, ...
            'dynamic_square', struct(...
                'length', L_energy_square, ...
                'target_length', ideal_length, ...
                'mask', energy_square_mask, ...
                'energy_ratio', actual_energy_ratio), ...
            'uniformity', struct(...
                'raw_rms', rms_uniformity, ...
                'stats', uniformity_stats), ...
            'penalties', struct(...
                'area', struct('value', area_penalty, 'stats', area_stats), ...
                'edge', struct('value', edge_penalty, 'stats', edge_stats), ...
                'energy', struct('value', energy_penalty, 'stats', energy_stats)), ...
            'weights', struct(...
                'rms', w_rms, ...
                'area', w_area, ...
                'edge', w_edge, ...
                'energy', w_energy), ...
            'objective_value', uniformity);
        
        fprintf('\n光路参数评估结果 [%s]:\n', datestr(now, 'yyyy-mm-dd HH:MM:SS'));
        fprintf('  - 动态方形区域边长: %.2f mm (目标: %.2f mm)\n', L_energy_square*1e3, ideal_length*1e3);
        fprintf('  - RMS均匀度: %.2f%% (权重: %.3f)\n', rms_uniformity, w_rms);
        fprintf('  - 面积惩罚: %.4f (权重: %.3f)\n', area_penalty, w_area);
        fprintf('  - 边缘陡峭度惩罚: %.4f (权重: %.3f)\n', edge_penalty, w_edge);
        fprintf('  - 固定区域能量惩罚: %.4f (权重: %.3f)\n', energy_penalty, w_energy);
        fprintf('  - 总目标值: %.4f\n', uniformity);
        
    catch ME
        warning('光路参数评估失败: %s', ME.message);
        uniformity = inf;
        details_for_saving = struct('error', ME.message);
    end
end

function finalize_optimization_enhanced(best_solution, X, Y, dx, lambda, history)
    % 使用精确评估函数完成优化并保存结果
    fprintf('\n正在完成优化并保存结果...\n');
    
    % 使用精确评估函数重新评估最优解
    fprintf('\n====================== 最终精确评估 ======================\n');
    fprintf('开始时间: %s\n', datestr(history.start_time, 'yyyy-mm-dd HH:MM:SS'));
    fprintf('总迭代次数: %d\n', size(history.points, 1));
    fprintf('最优解获得时间: %s\n', best_solution.timestamp);
    fprintf('最优参数:\n');
    fprintf('  - 最大网格偏移: %.2f μm\n', best_solution.parameters(1)*1e6);
    fprintf('  - 最大中心偏移比例: %.2f\n', best_solution.parameters(2));
    fprintf('  - 最大矢高偏移比例: %.2f\n', best_solution.parameters(3));
    fprintf('  - 微透镜尺寸: %.2f μm\n', best_solution.parameters(4)*1e6);
    fprintf('  - 矢高: %.2f μm\n', best_solution.parameters(5)*1e6);
    fprintf('  - d1: %.2f mm\n', best_solution.parameters(6)*1e3);
    fprintf('  - d2: %.2f mm\n', best_solution.parameters(7)*1e3);
    fprintf('  - d3: %.2f mm\n', best_solution.parameters(8)*1e3);
    
    % 使用精确评估函数重新评估
    fprintf('\n正在使用精确评估函数重新评估最优解...\n');
    [precise_uniformity, precise_intensity, precise_details] = evaluate_mla_design_precise(...
        best_solution.parameters, X, Y, dx, lambda);
    
    fprintf('精确评估结果:\n');
    fprintf('  - 均匀度: %.4f%%\n', precise_uniformity * 100);
    fprintf('  - 动态方形区域边长: %.2f mm\n', precise_details.uniformity.evaluation_area.square_size * 1e3);
    
    % 创建结果保存目录
    result_dir = sprintf('optimization_results/result_%s', ...
        datestr(now, 'yyyy-mm-dd_HH-MM-SS'));
    mkdir_if_not_exists(result_dir);
    
    % 创建符合期望格式的数据结构
    optimization_data = struct();
    
    % 设置MLA设计信息
    optimization_data.mla_design = struct();
    optimization_data.mla_design.parameters = best_solution.parameters;
    optimization_data.mla_design.thickness_distribution = best_solution.details.physical_structure.thickness_total;
    
    % 设置grid字段
    optimization_data.grid = struct();
    optimization_data.grid.dx = dx;
    optimization_data.grid.X = X;
    optimization_data.grid.Y = Y;
    optimization_data.grid.lambda = lambda;
    
    % 添加优化相关信息
    optimization_data.optimization = struct();
    optimization_data.optimization.history = history;
    optimization_data.optimization.best_solution = best_solution;
    optimization_data.optimization.precise_evaluation = struct(...
        'uniformity', precise_uniformity, ...
        'intensity', precise_intensity, ...
        'details', precise_details);
    
    % 添加元数据
    optimization_data.metadata = struct(...
        'timestamp', datestr(now, 'yyyy-mm-dd_HH-MM-SS'), ...
        'user', 'yoka02035', ...
        'matlab_version', version);
    
    % 保存为MAT文件
    save_name = sprintf('%s/optimization_result.mat', result_dir);
    save(save_name, '-struct', 'optimization_data');
    fprintf('结果已保存至: %s\n', save_name);
    
    % 绘制并保存最终结果图
    plot_optimization_results(precise_intensity, dx, history, best_solution.parameters);
    
    fprintf('========================================================\n\n');
    fprintf('优化完成！\n');
end

function [uniformity, intensity, details] = evaluate_mla_design_precise(params, X, Y, dx, lambda)
    % 精确评估MLA设计的函数
    % 输入:
    %   params - 设计参数 [max_shift, max_center_shift, max_sag_shift, ml_size, ml_sag, d1, d2, d3]
    %   X, Y - 坐标网格
    %   dx - 采样间隔
    %   lambda - 波长
    % 输出:
    %   uniformity - 均匀度评估值
    %   intensity - 输出光强分布
    %   details - 详细信息结构体
    
    % 解析所有8个参数
    max_shift = params(1);
    max_center_shift = params(2);
    max_sag_shift = params(3);
    ml_size = params(4);
    ml_sag = params(5);
    d1 = params(6);
    d2 = params(7);
    d3 = params(8);
    
    % 其他参数设置
    base_thickness = 20e-6;
    n = 2.4;
    N_array = 20;
    
    % 生成高精度MLA
    [T_mla, thickness_total, generation_details] = generate_random_mla(...
        X, Y, ml_size, ml_sag, base_thickness, n, N_array, ...
        max_shift, max_center_shift, max_sag_shift, lambda);
    
    % 使用双精度进行光束传播
    intensity = simulate_beam_propagation(T_mla, X, Y, dx, lambda, d1, d2, d3);
    intensity_norm = intensity / max(intensity(:));
    
    % 计算包含90%总能量的动态区域
    target_energy_ratio = 0.9;
    [valid_mask, L_square] = find_dynamic_energy_square(intensity, dx, target_energy_ratio, X, Y);
    
    % 计算各种评估指标
    [rms_uniformity, uniformity_stats] = calculate_uniformity_in_region(intensity_norm, valid_mask);
    [area_penalty, area_stats] = calculate_area_constraint_penalty(L_square, 12e-3);
    [edge_penalty, edge_stats] = calculate_edge_steepness_penalty(intensity_norm, valid_mask);
    [energy_penalty, energy_stats] = calculate_fixed_region_energy_penalty(intensity_norm, X, Y);
    
    % 计算加权目标函数值
    w_rms_raw = 4.0;
    w_area_raw = 3.0;
    w_edge_raw = 0.25;
    w_energy_raw = 3.0;
    
    total_weight = w_rms_raw + w_area_raw + w_edge_raw + w_energy_raw;
    
    w_rms = w_rms_raw / total_weight;
    w_area = w_area_raw / total_weight;
    w_edge = w_edge_raw / total_weight;
    w_energy = w_energy_raw / total_weight;
    
    uniformity = w_rms * rms_uniformity/100 + ...
                w_area * area_penalty + ...
                w_edge * edge_penalty + ...
                w_energy * energy_penalty;
    
    % 收集详细信息
    details = struct();
    details.uniformity = struct(...
        'raw_rms', rms_uniformity, ...
        'stats', uniformity_stats, ...
        'evaluation_area', struct(...
            'square_size', L_square, ...
            'energy_ratio', target_energy_ratio));
    
    details.penalties = struct(...
        'area', struct('value', area_penalty, 'stats', area_stats), ...
        'edge', struct('value', edge_penalty, 'stats', edge_stats), ...
        'energy', struct('value', energy_penalty, 'stats', energy_stats));
    
    details.weights = struct(...
        'rms', w_rms, ...
        'area', w_area, ...
        'edge', w_edge, ...
        'energy', w_energy);
    
    details.objective_value = uniformity;
    details.generation = generation_details;
    
    % 输出详细评估结果
    fprintf('\n精确评估结果 [%s]:\n', datestr(now, 'yyyy-mm-dd HH:MM:SS'));
    fprintf('  - 动态方形区域边长: %.2f mm (目标: %.2f mm)\n', L_square*1e3, 12);
    fprintf('  - RMS均匀度: %.2f%% (权重: %.3f)\n', rms_uniformity, w_rms);
    fprintf('  - 面积惩罚: %.4f (权重: %.3f)\n', area_penalty, w_area);
    fprintf('  - 边缘陡峭度惩罚: %.4f (权重: %.3f)\n', edge_penalty, w_edge);
    fprintf('  - 固定区域能量惩罚: %.4f (权重: %.3f)\n', energy_penalty, w_energy);
    fprintf('  - 总目标值: %.4f\n', uniformity);
end

function plot_optimization_results(intensity, dx, history, best_params)
    % 绘制优化结果
    figure('Name', '优化结果可视化', 'Position', [100, 100, 1200, 900]);
    
    % 计算物理坐标
    N = size(intensity, 1);
    x = ((-N/2:N/2-1) * dx) * 1e3;  % 转换为毫米
    
    % 1. 二维光强分布
    subplot(2, 2, 1);
    imagesc(x, x, intensity);
    axis square;
    colormap('jet');
    h = colorbar;
    ylabel(h, '归一化强度');
    title('优化后的输出光强度分布');
    xlabel('x (mm)');
    ylabel('y (mm)');
    xlim([-10 10]);
    ylim([-10 10]);
    grid on;
    
    % 2. 中心放大区域
    subplot(2, 2, 2);
    imagesc(x, x, intensity);
    axis square;
    colorbar;
    title('输出强度分布 - 中心放大');
    xlabel('x (mm)');
    ylabel('y (mm)');
    xlim([-6 6]);
    ylim([-6 6]);
    
    % 3. 中心水平剖面
    subplot(2, 2, 3);
    center_row = round(size(intensity, 1)/2);
    plot(x, intensity(center_row, :), 'LineWidth', 2);
    grid on;
    title('水平中心剖面');
    xlabel('x (mm)');
    ylabel('归一化强度');
    xlim([-10 10]);
    
    % 4. 优化历史
    subplot(2, 2, 4);
    plot(1:length(history.values), history.values, 'o-', 'LineWidth', 1.5);
    grid on;
    title('优化历史');
    xlabel('迭代次数');
    ylabel('目标函数值');
    
    % 添加文本注释
    annotation('textbox', [0.02, 0.02, 0.4, 0.05], ...
        'String', sprintf('最优参数: 尺寸=%.2fμm, 矢高=%.2fμm, d1=%.2fmm, d2=%.2fmm, d3=%.2fmm', ...
        best_params(4)*1e6, best_params(5)*1e6, best_params(6)*1e3, best_params(7)*1e3, best_params(8)*1e3), ...
        'EdgeColor', 'none', 'FontSize', 10);
    
    % 保存图像
    result_dir = sprintf('optimization_results/result_%s', ...
        datestr(now, 'yyyy-mm-dd_HH-MM-SS'));
    if ~exist(result_dir, 'dir')
        mkdir(result_dir);
    end
    saveas(gcf, sprintf('%s/optimization_result_plot.png', result_dir));
    saveas(gcf, sprintf('%s/optimization_result_plot.fig', result_dir));
    
    % 创建额外的剖面图
    figure('Name', '光强分布剖面', 'Position', [100, 100, 1200, 500]);
    
    % 水平剖面
    subplot(1, 2, 1);
    center_row = round(size(intensity, 1)/2);
    plot(x, intensity(center_row, :), 'LineWidth', 2);
    grid on;
    title('水平中心剖面');
    xlabel('x (mm)');
    ylabel('归一化强度');
    xlim([-10 10]);
    
    % 垂直剖面
    subplot(1, 2, 2);
    center_col = round(size(intensity, 2)/2);
    plot(x, intensity(:, center_col), 'LineWidth', 2);
    grid on;
    title('垂直中心剖面');
    xlabel('y (mm)');
    ylabel('归一化强度');
    xlim([-10 10]);
    
    % 保存剖面图
    saveas(gcf, sprintf('%s/intensity_profiles.png', result_dir));
    saveas(gcf, sprintf('%s/intensity_profiles.fig', result_dir));
end

function I_out_norm = simulate_beam_propagation_fixed_mla(T_mla, X, Y, dx, lambda, d1, d2, d3)
    % 使用固定MLA设计的光束传播模拟
    % 输入:
    %   T_mla - 已优化的MLA复振幅透射率
    %   X, Y - 坐标网格
    %   dx - 采样间隔
    %   lambda - 波长
    %   d1, d2, d3 - 光路参数
    % 输出:
    %   I_out_norm - 归一化输出强度分布
    
    % 光学参数设置
    w0 = 3.5e-3;        % 入射光束半径3.5mm
    I0 = 1;
    R = sqrt(X.^2 + Y.^2);
    U0 = sqrt(I0)*exp(-R.^2/w0^2);
    
    % 傅里叶透镜焦距
    f = 50e-3;      % 傅里叶透镜焦距50mm保持不变
    
    % 光束传播
    U1 = U0.*T_mla;
    U1_prop = prop_angular_spectrum(U1, dx, lambda, d1);
    U2 = U1_prop.*T_mla;
    U1_propagated = prop_angular_spectrum(U2, dx, lambda, d2);
    
    % 傅里叶透镜
    T_lens = exp(-1i*2*pi/lambda*(X.^2 + Y.^2)/(2*f));
    U3 = U1_propagated.*T_lens;
    
    % 传播到目标面
    U_focal = prop_angular_spectrum(U3, dx, lambda, d3);
    
    % 计算归一化强度
    I_out = abs(U_focal).^2;
    I_out_norm = single(I_out/max(I_out(:)));
end

function next_point = select_next_optical_point(model, lb, ub, best_value)
    % 选择下一个光路参数评估点
    validateattributes(lb, {'numeric'}, {'vector', 'numel', 3}, ...
        'select_next_optical_point', 'lb');
    validateattributes(ub, {'numeric'}, {'vector', 'numel', 3}, ...
        'select_next_optical_point', 'ub');
    
    n_dims = 3;  % 光路参数维度
    
    % 优化参数
    n_starts = 30;        % 随机起点数量
    
    % 初始化
    best_ei = -Inf;
    best_point = lb + (ub-lb).*rand(1, n_dims);  % 默认值
    
    % 优化选项
    options = optimoptions('fmincon', ...
        'Algorithm', 'sqp', ...
        'Display', 'off', ...
        'MaxFunctionEvaluations', 1000, ...
        'MaxIterations', 500, ...
        'SpecifyObjectiveGradient', false, ...
        'CheckGradients', false, ...
        'OptimalityTolerance', 1e-6, ...
        'StepTolerance', 1e-6, ...
        'FunctionTolerance', 1e-6);
    
    % 定义目标函数
    obj_fun = @(x) safe_ei_calculation(x, model, best_value);
    
    % 多起点优化
    for i = 1:n_starts
        % 生成随机起点
        x0 = lb + (ub-lb).*rand(1, n_dims);
        
        try
            % 运行优化
            [x_opt, ei_val] = fmincon(obj_fun, x0, [], [], [], [], lb, ub, [], options);
            
            % 更新最优解
            if isfinite(ei_val) && -ei_val > best_ei
                best_ei = -ei_val;
                best_point = x_opt;
            end
        catch ME
            warning('优化尝试 %d 失败: %s', i, ME.message);
            continue;
        end
    end
    
    % 确保返回的点是行向量
    best_point = best_point(:)';
    next_point = best_point;
end

function save_optical_checkpoint(iter, model, history, best_solution)
    % 保存光路参数优化检查点
    validateattributes(iter, {'numeric'}, {'scalar', 'positive', 'integer'}, ...
        'save_optical_checkpoint', 'iter');
    
    % 创建检查点文件名
    filename = sprintf('checkpoints/optical_checkpoint_iter_%d.mat', iter);
    
    % 准备检查点数据
    checkpoint = struct();
    checkpoint.iteration = iter;
    checkpoint.model = model;
    checkpoint.history = history;
    checkpoint.best_solution = best_solution;
    checkpoint.timestamp = datestr(now, 'yyyy-mm-dd_HH-MM-SS');
    
    % 添加额外的元数据
    checkpoint.metadata = struct();
    checkpoint.metadata.save_date = datetime('now', 'Format', 'yyyy-MM-dd HH:mm:ss');
    checkpoint.metadata.username = getenv('USERNAME');
    checkpoint.metadata.matlab_version = version;
    
    try
        % 保存检查点
        save(filename, '-struct', 'checkpoint');
        fprintf('光路参数优化检查点已保存: %s\n', filename);
    catch ME
        warning('保存检查点失败: %s\n文件: %s', ME.message, filename);
    end
end

function display_optical_progress(iter, max_iter, best_solution)
    % 显示光路参数优化进度
    % 计算进度百分比
    progress = (iter/max_iter) * 100;
    
    % 绘制简单的文本进度条
    bar_width = 50;
    filled = round(progress * bar_width / 100);
    bar = ['[' repmat('=', 1, filled) repmat(' ', 1, bar_width-filled) ']'];
    
    % 清除当前行
    fprintf('\r');
    
    % 显示进度信息
    fprintf('%s %.1f%% ', bar, progress);
    fprintf('迭代: %d/%d ', iter, max_iter);
    fprintf('最优值: %.6f\n', best_solution.value);
    
    % 如果有最优参数,显示参数信息
    if ~isempty(best_solution.parameters)
        fprintf('当前最优光路参数：\n');
        fprintf('  d1: %.2f mm\n', best_solution.parameters(1)*1e3);
        fprintf('  d2: %.2f mm\n', best_solution.parameters(2)*1e3);
        fprintf('  d3: %.2f mm\n', best_solution.parameters(3)*1e3);
    end
    
    % 添加时间戳
    if isfield(best_solution, 'timestamp')
        fprintf('最优解更新时间: %s\n', best_solution.timestamp);
    end
end

function converged = check_optical_convergence(history, iter)
    % 检查光路参数优化是否收敛
    if iter < 10
        converged = false;
        return;
    end
    
    % 检查最近10次迭代的改进
    recent_values = history.values(end-9:end);
    improvement = abs(recent_values(1) - recent_values(end)) / abs(recent_values(1));
    
    % 添加参数稳定性检查
    recent_points = history.points(end-9:end, :);
    param_stability = std(recent_points);
    
    % 分别设置不同参数的收敛阈值（3个参数）
    thresholds = [1e-6, 1e-6, 1e-6];  % 对应d1, d2, d3
    param_converged = all(param_stability <= thresholds);
    
    % 综合判断收敛性
    converged = improvement < 1e-6 && param_converged;
    
    % 输出收敛信息
    if converged
        fprintf('光路参数优化已收敛:\n');
        fprintf('  - 目标函数改进: %.2e\n', improvement);
        fprintf('  - 参数稳定性: %.2e %.2e %.2e\n', param_stability);
    end
end

function finalize_optical_optimization(best_solution, T_mla, thickness_total, X, Y, dx, lambda, history)
    % 完成光路参数优化并保存结果
    fprintf('\n正在完成光路参数优化并保存结果...\n');
    
    % 使用最优参数重新生成高精度结果
    fprintf('\n====================== 光路参数优化最终结果 ======================\n');
    fprintf('开始时间: %s\n', datestr(history.start_time, 'yyyy-mm-dd HH:MM:SS'));
    fprintf('总迭代次数: %d\n', size(history.points, 1));
    fprintf('最优解获得时间: %s\n', best_solution.timestamp);
    fprintf('最优光路参数:\n');
    fprintf('  - d1: %.2f mm\n', best_solution.parameters(1)*1e3);
    fprintf('  - d2: %.2f mm\n', best_solution.parameters(2)*1e3);
    fprintf('  - d3: %.2f mm\n', best_solution.parameters(3)*1e3);
    
    % 从best_solution.details中提取相关信息
    dynamic_square = best_solution.details.dynamic_square;
    uniformity = best_solution.details.uniformity;
    penalties = best_solution.details.penalties;
    weights = best_solution.details.weights;
    
    % 展示评估结果
    fprintf('\n评估结果 [%s]:\n', best_solution.timestamp);
    fprintf('  - 动态方形区域边长: %.2f mm (目标: %.2f mm)\n', ...
        dynamic_square.length*1e3, dynamic_square.target_length*1e3);
    fprintf('  - RMS均匀度: %.2f%% (权重: %.3f)\n', ...
        uniformity.raw_rms, weights.rms);
    fprintf('  - 面积惩罚: %.4f (权重: %.3f)\n', ...
        penalties.area.value, weights.area);
    fprintf('  - 边缘陡峭度惩罚: %.4f (权重: %.3f)\n', ...
        penalties.edge.value, weights.edge);
    fprintf('  - 固定区域能量惩罚: %.4f (权重: %.3f)\n', ...
        penalties.energy.value, weights.energy);
    fprintf('  - 总目标值: %.4f\n\n', best_solution.value);
    
    % 使用最优光路参数重新模拟光束传播
    fprintf('\n正在使用最优光路参数重新模拟光束传播...\n');
    final_intensity = simulate_beam_propagation_fixed_mla(T_mla, X, Y, dx, lambda, ...
        best_solution.parameters(1), best_solution.parameters(2), best_solution.parameters(3));
    
    % 创建结果保存目录
    result_dir = sprintf('optimization_results/optical_path_result_%s', ...
        datestr(now, 'yyyy-mm-dd_HH-MM-SS'));
    mkdir_if_not_exists(result_dir);
    
    % 创建符合期望格式的数据结构
    optical_data = struct();
    
    % 设置MLA设计信息
    optical_data.mla_design = struct();
    optical_data.mla_design.T_mla = T_mla;
    optical_data.mla_design.thickness_total = thickness_total;
    
    % 设置grid字段
    optical_data.grid = struct();
    optical_data.grid.dx = dx;
    optical_data.grid.X = X;
    optical_data.grid.Y = Y;
    optical_data.grid.lambda = lambda;
    
    % 添加优化相关信息
    optical_data.optimization = struct();
    optical_data.optimization.parameters = best_solution.parameters;
    optical_data.optimization.performance = struct('uniformity', uniformity.raw_rms/100);
    optical_data.optimization.history = history;
    optical_data.optimization.final_intensity = final_intensity;
    
    % 添加元数据
    optical_data.metadata = struct(...
        'timestamp', datestr(now, 'yyyy-mm-dd_HH-MM-SS'), ...
        'user', 'yoka02035', ...
        'matlab_version', version);
    
    % 保存为MAT文件
    save_name = sprintf('%s/optical_path_optimization.mat', result_dir);
    save(save_name, '-struct', 'optical_data');
    fprintf('结果已保存至: %s\n', save_name);
    
    % 绘制并保存最终结果图
    plot_optical_optimization_results(final_intensity, dx, history, best_solution.parameters);
    
    fprintf('========================================================\n\n');
    fprintf('光路参数优化完成！\n');
end

function plot_optical_optimization_results(intensity, dx, history, best_params)
    % 绘制光路参数优化结果
    figure('Name', '光路参数优化结果可视化', 'Position', [100, 100, 1200, 900]);
    
    % 计算物理坐标
    N = size(intensity, 1);
    x = ((-N/2:N/2-1) * dx) * 1e3;  % 转换为毫米
    
    % 1. 二维光强分布
    subplot(2, 2, 1);
    imagesc(x, x, intensity);
    axis square;
    colormap('jet');
    h = colorbar;
    ylabel(h, '归一化强度');
    title('优化光路参数后的输出光强度分布');
    xlabel('x (mm)');
    ylabel('y (mm)');
    xlim([-10 10]);
    ylim([-10 10]);
    grid on;
    
    % 2. 中心放大区域
    subplot(2, 2, 2);
    imagesc(x, x, intensity);
    axis square;
    colorbar;
    title('输出强度分布 - 中心放大');
    xlabel('x (mm)');
    ylabel('y (mm)');
    xlim([-6 6]);
    ylim([-6 6]);
    
    % 3. 中心水平剖面
    subplot(2, 2, 3);
    center_row = round(size(intensity, 1)/2);
    plot(x, intensity(center_row, :), 'LineWidth', 2);
    grid on;
    title('水平中心剖面');
    xlabel('x (mm)');
    ylabel('归一化强度');
    xlim([-10 10]);
    
    % 4. 优化历史
    subplot(2, 2, 4);
    plot(1:length(history.values), history.values, 'o-', 'LineWidth', 1.5);
    grid on;
    title('优化历史');
    xlabel('迭代次数');
    ylabel('目标函数值');
    
    % 添加文本注释
    annotation('textbox', [0.02, 0.02, 0.4, 0.05], ...
        'String', sprintf('最优光路参数: d1=%.2fmm, d2=%.2fmm, d3=%.2fmm', ...
        best_params(1)*1e3, best_params(2)*1e3, best_params(3)*1e3), ...
        'EdgeColor', 'none', 'FontSize', 10);
    
    % 保存图像
    result_dir = sprintf('optimization_results/optical_path_result_%s', ...
        datestr(now, 'yyyy-mm-dd_HH-MM-SS'));
    if ~exist(result_dir, 'dir')
        mkdir(result_dir);
    end
    saveas(gcf, sprintf('%s/optimization_result_plot.png', result_dir));
    saveas(gcf, sprintf('%s/optimization_result_plot.fig', result_dir));
    
    % 创建额外的剖面图
    figure('Name', '光强分布剖面', 'Position', [100, 100, 1200, 500]);
    
    % 水平剖面
    subplot(1, 2, 1);
    center_row = round(size(intensity, 1)/2);
    plot(x, intensity(center_row, :), 'LineWidth', 2);
    grid on;
    title('水平中心剖面');
    xlabel('x (mm)');
    ylabel('归一化强度');
    xlim([-10 10]);
    
    % 垂直剖面
    subplot(1, 2, 2);
    center_col = round(size(intensity, 2)/2);
    plot(x, intensity(:, center_col), 'LineWidth', 2);
    grid on;
    title('垂直中心剖面');
    xlabel('y (mm)');
    ylabel('归一化强度');
    xlim([-10 10]);
    
    % 保存剖面图
    saveas(gcf, sprintf('%s/intensity_profiles.png', result_dir));
    saveas(gcf, sprintf('%s/intensity_profiles.fig', result_dir));
    
    % 创建3D表面图
    figure('Name', '光强分布3D表面', 'Position', [100, 100, 800, 600]);
    [X_mesh, Y_mesh] = meshgrid(x, x);
    surf(X_mesh, Y_mesh, intensity);
    shading interp;
    colormap('jet');
    colorbar;
    title('输出光强度分布 - 3D表面');
    xlabel('x (mm)');
    ylabel('y (mm)');
    zlabel('归一化强度');
    xlim([-10 10]);
    ylim([-10 10]);
    view(45, 30);
    
    % 保存3D表面图
    saveas(gcf, sprintf('%s/intensity_3d_surface.png', result_dir));
    saveas(gcf, sprintf('%s/intensity_3d_surface.fig', result_dir));
    
    % 创建优化历史详细图
    figure('Name', '优化历史详细', 'Position', [100, 100, 1200, 900]);
    
    % 目标函数历史
    subplot(2, 2, 1);
    plot(1:length(history.values), history.values, 'o-', 'LineWidth', 1.5);
    hold on;
    [min_val, min_idx] = min(history.values);
    plot(min_idx, min_val, 'ro', 'MarkerSize', 10, 'LineWidth', 2);
    grid on;
    title('目标函数优化历史');
    xlabel('迭代次数');
    ylabel('目标函数值');
    
    % d1参数历史
    subplot(2, 2, 2);
    d1_history = zeros(length(history.values), 1);
    for i = 1:length(history.values)
        d1_history(i) = history.points(i, 1);
    end
    plot(1:length(d1_history), d1_history*1e3, 'o-', 'LineWidth', 1.5);
    grid on;
    title('d1参数优化历史');
    xlabel('迭代次数');
    ylabel('d1 (mm)');
    
    % d2参数历史
    subplot(2, 2, 3);
    d2_history = zeros(length(history.values), 1);
    for i = 1:length(history.values)
        d2_history(i) = history.points(i, 2);
    end
    plot(1:length(d2_history), d2_history*1e3, 'o-', 'LineWidth', 1.5);
    grid on;
    title('d2参数优化历史');
    xlabel('迭代次数');
    ylabel('d2 (mm)');
    
    % d3参数历史
    subplot(2, 2, 4);
    d3_history = zeros(length(history.values), 1);
    for i = 1:length(history.values)
        d3_history(i) = history.points(i, 3);
    end
    plot(1:length(d3_history), d3_history*1e3, 'o-', 'LineWidth', 1.5);
    grid on;
    title('d3参数优化历史');
    xlabel('迭代次数');
    ylabel('d3 (mm)');
    
    % 保存优化历史详细图
    saveas(gcf, sprintf('%s/optimization_history_detailed.png', result_dir));
    saveas(gcf, sprintf('%s/optimization_history_detailed.fig', result_dir));
    
    % 创建光强分布热图
    figure('Name', '光强分布热图', 'Position', [100, 100, 800, 700]);
    
    % 使用热图显示光强分布
    imagesc(x, x, intensity);
    axis square;
    colormap('hot');
    h = colorbar;
    ylabel(h, '归一化强度');
    title('输出光强度分布 - 热图');
    xlabel('x (mm)');
    ylabel('y (mm)');
    xlim([-10 10]);
    ylim([-10 10]);
    
    % 添加等高线
    hold on;
    contour(x, x, intensity, 5, 'w', 'LineWidth', 0.5);
    
    % 保存热图
    saveas(gcf, sprintf('%s/intensity_heatmap.png', result_dir));
    saveas(gcf, sprintf('%s/intensity_heatmap.fig', result_dir));
    
    % 创建参数空间可视化图
    if length(history.values) > 10
        figure('Name', '参数空间可视化', 'Position', [100, 100, 1000, 800]);
        
        % 创建3D散点图，颜色表示目标函数值
        scatter3(history.points(:,1)*1e3, history.points(:,2)*1e3, history.points(:,3)*1e3, ...
            50, history.values, 'filled');
        colormap('jet');
        colorbar;
        
        % 标记最优点
        hold on;
        [~, best_idx] = min(history.values);
        scatter3(history.points(best_idx,1)*1e3, history.points(best_idx,2)*1e3, ...
            history.points(best_idx,3)*1e3, 200, 'r', 'filled', 'MarkerEdgeColor', 'k');
        
        % 设置图形属性
        grid on;
        title('参数空间优化轨迹');
        xlabel('d1 (mm)');
        ylabel('d2 (mm)');
        zlabel('d3 (mm)');
        view(45, 30);
        
        % 保存参数空间可视化图
        saveas(gcf, sprintf('%s/parameter_space_visualization.png', result_dir));
        saveas(gcf, sprintf('%s/parameter_space_visualization.fig', result_dir));
    end
    
    fprintf('所有结果图表已保存至: %s\n', result_dir);
end

function history = initialize_history(initial_points, initial_values)
    % 初始化优化历史记录
    history = struct();
    history.points = initial_points;
    history.values = initial_values;
    history.start_time = now;
    history.timestamps = repmat(datetime('now'), size(initial_values));
    
    % 添加额外的统计信息
    history.best_value_per_iteration = min(initial_values);
    history.best_point_per_iteration = initial_points(find(initial_values == min(initial_values), 1), :);
    history.mean_value_per_iteration = mean(initial_values);
    history.std_value_per_iteration = std(initial_values);
    
    % 记录初始化信息
    fprintf('历史记录已初始化，包含 %d 个初始采样点\n', length(initial_values));
    fprintf('初始最优值: %.6f\n', history.best_value_per_iteration);
end

function history = update_history(history, next_point, next_value)
    % 更新优化历史记录
    history.points = [history.points; next_point];
    history.values = [history.values; next_value];
    history.timestamps = [history.timestamps; datetime('now')];
    
    % 更新统计信息
    current_best = min(history.values);
    current_best_idx = find(history.values == current_best, 1);
    history.best_value_per_iteration = [history.best_value_per_iteration; current_best];
    history.best_point_per_iteration = [history.best_point_per_iteration; history.points(current_best_idx, :)];
    history.mean_value_per_iteration = [history.mean_value_per_iteration; mean(history.values)];
    history.std_value_per_iteration = [history.std_value_per_iteration; std(history.values)];
    
    return;
end

function surrogate_model = train_surrogate_model(points, values)
    % 训练代理模型
    % 输入:
    %   points - 采样点矩阵，每行是一个采样点
    %   values - 对应的函数值向量
    % 输出:
    %   surrogate_model - 训练好的代理模型
    
    % 验证输入
    validateattributes(points, {'numeric'}, {'2d'}, 'train_surrogate_model', 'points');
    validateattributes(values, {'numeric'}, {'vector', 'numel', size(points, 1)}, ...
        'train_surrogate_model', 'values');
    
    % 确保values是列向量
    values = values(:);
    
    % 创建高斯过程回归模型
    fprintf('正在训练代理模型，使用 %d 个采样点...\n', length(values));
    
    % 设置高斯过程回归选项
    gpr_options = struct();
    gpr_options.Standardize = true;
    gpr_options.Verbose = 0;
    gpr_options.KernelFunction = 'ardsquaredexponential';
    gpr_options.OptimizeHyperparameters = 'auto';
    gpr_options.HyperparameterOptimizationOptions = struct(...
        'AcquisitionFunctionName', 'expected-improvement', ...
        'MaxObjectiveEvaluations', 30, ...
        'ShowPlots', false, ...
        'Verbose', 0);
    
    try
        % 训练高斯过程回归模型
        gpr_model = fitrgp(points, values, 'Options', gpr_options);
        
        % 创建代理模型结构体
        surrogate_model = struct();
        surrogate_model.type = 'gaussian_process';
        surrogate_model.model = gpr_model;
        surrogate_model.training_points = points;
        surrogate_model.training_values = values;
        surrogate_model.timestamp = datestr(now, 'yyyy-mm-dd_HH-MM-SS');
        
        % 计算训练误差
        predicted = predict(gpr_model, points);
        rmse = sqrt(mean((predicted - values).^2));
        surrogate_model.training_rmse = rmse;
        
        fprintf('代理模型训练完成，训练RMSE: %.6f\n', rmse);
        
    catch ME
        warning('代理模型训练失败: %s\n尝试使用备用方法...', ME.message);
        
        % 备用方法：使用简单的径向基函数
        rbf_model = newrbe(points', values');
        
        surrogate_model = struct();
        surrogate_model.type = 'rbf_network';
        surrogate_model.model = rbf_model;
        surrogate_model.training_points = points;
        surrogate_model.training_values = values;
        surrogate_model.timestamp = datestr(now, 'yyyy-mm-dd_HH-MM-SS');
        
        % 计算训练误差
        predicted = sim(rbf_model, points')';
        rmse = sqrt(mean((predicted - values).^2));
        surrogate_model.training_rmse = rmse;
        
        fprintf('备用RBF网络模型训练完成，训练RMSE: %.6f\n', rmse);
    end
end

function surrogate_model = update_surrogate_model(surrogate_model, new_point, new_value)
    % 更新代理模型
    % 输入:
    %   surrogate_model - 现有代理模型
    %   new_point - 新的采样点
    %   new_value - 对应的函数值
    % 输出:
    %   surrogate_model - 更新后的代理模型
    
    % 确保new_point是行向量
    new_point = reshape(new_point, 1, []);
    
    % 更新训练数据
    surrogate_model.training_points = [surrogate_model.training_points; new_point];
    surrogate_model.training_values = [surrogate_model.training_values; new_value];
    
    % 根据模型类型进行更新
    if strcmp(surrogate_model.type, 'gaussian_process')
        try
            % 重新训练高斯过程回归模型
            gpr_options = struct();
            gpr_options.Standardize = true;
            gpr_options.Verbose = 0;
            gpr_options.KernelFunction = 'ardsquaredexponential';
            
            % 使用现有模型的超参数作为初始值
            existing_model = surrogate_model.model;
            if isprop(existing_model, 'KernelInformation') && ...
               isfield(existing_model.KernelInformation, 'KernelParameters')
                gpr_options.KernelParameters = existing_model.KernelInformation.KernelParameters;
            end
            
            % 重新训练模型
            surrogate_model.model = fitrgp(surrogate_model.training_points, ...
                surrogate_model.training_values, 'Options', gpr_options);
            
            % 更新时间戳
            surrogate_model.timestamp = datestr(now, 'yyyy-mm-dd_HH-MM-SS');
            
            % 计算训练误差
            predicted = predict(surrogate_model.model, surrogate_model.training_points);
            rmse = sqrt(mean((predicted - surrogate_model.training_values).^2));
            surrogate_model.training_rmse = rmse;
            
        catch ME
            warning('代理模型更新失败: %s\n保持使用现有模型', ME.message);
        end
    elseif strcmp(surrogate_model.type, 'rbf_network')
        try
            % 重新训练RBF网络
            surrogate_model.model = newrbe(surrogate_model.training_points', ...
                surrogate_model.training_values');
            
            % 更新时间戳
            surrogate_model.timestamp = datestr(now, 'yyyy-mm-dd_HH-MM-SS');
            
            % 计算训练误差
            predicted = sim(surrogate_model.model, surrogate_model.training_points')';
            rmse = sqrt(mean((predicted - surrogate_model.training_values).^2));
            surrogate_model.training_rmse = rmse;
            
        catch ME
            warning('RBF网络模型更新失败: %s\n保持使用现有模型', ME.message);
        end
    end
end

function [ei_val, grad] = safe_ei_calculation(x, model, best_value)
    % 安全的期望改进计算函数
    % 输入:
    %   x - 评估点
    %   model - 代理模型
    %   best_value - 当前最优值
    % 输出:
    %   ei_val - 期望改进值（负值，用于最小化）
    %   grad - 梯度（如果可用）
    
    % 初始化返回值
    ei_val = 0;
    grad = [];
    
    try
        % 确保x是行向量
        x = reshape(x, 1, []);
        
        % 根据模型类型进行预测
        if strcmp(model.type, 'gaussian_process')
            % 使用高斯过程回归模型进行预测
            [pred, std_pred] = predict(model.model, x);
            
            % 计算标准化改进
            improvement = best_value - pred;
            
            % 避免除以零
            if std_pred > 1e-10
                z = improvement / std_pred;
                
                % 计算期望改进
                ei = improvement * normcdf(z) + std_pred * normpdf(z);
                
                % 返回负值（用于最小化）
                ei_val = -max(0, ei);
            else
                % 如果标准差接近零，根据改进值设置EI
                if improvement > 0
                    ei_val = -improvement;  % 有改进，返回负的改进值
                else
                    ei_val = 0;  % 无改进
                end
            end
        elseif strcmp(model.type, 'rbf_network')
            % 使用RBF网络进行预测
            pred = sim(model.model, x')';
            
            % 简单的改进计算（无不确定性估计）
            improvement = best_value - pred;
            
            % 返回负值（用于最小化）
            ei_val = -max(0, improvement);
        end
    catch ME
        warning('期望改进计算失败: %s\n返回零值', ME.message);
        ei_val = 0;
    end
end

function mkdir_if_not_exists(dir_path)
    % 如果目录不存在则创建
    if ~exist(dir_path, 'dir')
        mkdir(dir_path);
        fprintf('已创建目录: %s\n', dir_path);
    end
end

function handle_error(ME)
    % 错误处理函数
    fprintf('\n===== 错误报告 =====\n');
    fprintf('错误消息: %s\n', ME.message);
    fprintf('错误ID: %s\n', ME.identifier);
    
    % 显示错误堆栈
    fprintf('错误堆栈:\n');
    for i = 1:length(ME.stack)
        fprintf('  文件: %s\n', ME.stack(i).file);
        fprintf('  函数: %s\n', ME.stack(i).name);
        fprintf('  行号: %d\n', ME.stack(i).line);
        fprintf('\n');
    end
    
    % 保存错误信息到文件
    error_log_file = sprintf('logs/error_%s.txt', datestr(now, 'yyyy-mm-dd_HH-MM-SS'));
    fid = fopen(error_log_file, 'w');
    if fid ~= -1
        fprintf(fid, '===== 错误报告 =====\n');
        fprintf(fid, '时间: %s\n', datestr(now, 'yyyy-mm-dd HH:MM:SS'));
        fprintf(fid, '错误消息: %s\n', ME.message);
        fprintf(fid, '错误ID: %s\n', ME.identifier);
        
        fprintf(fid, '错误堆栈:\n');
        for i = 1:length(ME.stack)
            fprintf(fid, '  文件: %s\n', ME.stack(i).file);
            fprintf(fid, '  函数: %s\n', ME.stack(i).name);
            fprintf(fid, '  行号: %d\n', ME.stack(i).line);
            fprintf(fid, '\n');
        end
        
        fclose(fid);
        fprintf('错误日志已保存至: %s\n', error_log_file);
    else
        fprintf('无法创建错误日志文件\n');
    end
end
